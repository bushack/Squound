
remember
	- viewModels are page logic, they request data from repositories or services and they administer views, they contain no state
	- repositories cache state, and allow viewModels to read that state
	- services are the workhorses, they retrieve data and pass it to the source of the request, usually a repo

pagination
	- check functionality of Previous Page and Next Page when more items added to database

logging
	- ask!

navigation
	- ask!

contexts
	- package complimentary services etc into appropriate contexts which can then be injected into ctors
	- beware circular dependancies

events
	- remember, events can be subscribed to, should a class need to know when something happens
	- use weak events to avoid memory leaks?

images
	- must have at least one default image if none are returned by API to avoid crash
	- JPEG for photos of furniture — compress to ~70–80% quality for balance
	- Strip metadata (EXIF) to save space
	- ThumbnailUrl → 200×200px - 240x240px JPEG/WebP (~20 KB)
	- MediumUrl → 800–1200 px for detail page (~100–300 KB)
	- LargeUrl → full resolution for zoom (~500 KB–2 MB, loaded on demand only when zooming)

search
	- fetch thumbnail image(s) only
	- user typing keyword only finds exact matchess, needs partial match
	- incorporate keyword search? or remove in favour of below
	- add functionality to CoarseSearchPage user search entry
	- sort and filter menu
		- sort by recommended
		- filter by dimensions
		- filter by material

item page
	- must have at least one default image if none are returned by API to avoid crash
	- fetch images of assorted sizes
	- allow user to tap to zoom and scroll all images

TODO
	- ctrl+f find any TODOs throughout the solution